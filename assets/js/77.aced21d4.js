(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{637:function(e,v,_){"use strict";_.r(v);var t=_(14),r=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"_1-啥是数据响应式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-啥是数据响应式"}},[e._v("#")]),e._v(" 1.啥是数据响应式")]),e._v(" "),_("p",[e._v("所谓响数据应式就是能够使数据变化可以被检测到并且对这种变化做出响应的机制")]),e._v(" "),_("h2",{attrs:{id:"_2-为什么-vue-需要响应式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么-vue-需要响应式"}},[e._v("#")]),e._v(" 2.为什么 Vue 需要响应式")]),e._v(" "),_("p",[e._v("MVVM 框架中要解决的一个核心问题就是连接数据和视图层（Model 和 View)，通过数据驱动应用，数据变化从触发视图更新，")]),e._v(" "),_("p",[e._v("要做到这点就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理")]),e._v(" "),_("h2",{attrs:{id:"_3-它能带来哪些好处"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-它能带来哪些好处"}},[e._v("#")]),e._v(" 3.它能带来哪些好处")]),e._v(" "),_("p",[e._v("vue 通过数据响应式加虚拟 DOM 和 patch 算法，可以使我们只需要操作数据，完全不用接触繁琐的 DOM 操作，从而大大提升开发效率，降低开发难度")]),e._v(" "),_("h2",{attrs:{id:"_4-vue-中的响应式是怎么实现的-有哪些优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-中的响应式是怎么实现的-有哪些优缺点"}},[e._v("#")]),e._v(" 4.vue 中的响应式是怎么实现的？有哪些优缺点")]),e._v(" "),_("p",[e._v("vue2中的数据响应式会根据数据类型来做不同处理，如果是对象则采用"),_("code",[e._v("Object.defineProperty()")]),e._v("的方式定义数据拦截，当数据被访问或发生")]),e._v(" "),_("p",[e._v("变化时，可以感知并做出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。")]),e._v(" "),_("p",[e._v("其实就是以这7个方法的名称作为key，然后通过"),_("code",[e._v("Object.defineProperty()")]),e._v("对方法做拦截处理，对方法的参数进行响应式处理。")]),e._v(" "),_("p",[e._v("这种机制很好的解决了数据响应化的问题，但实际使用的情况先还是存在一些缺点：比如初始化时我们就不得不递归遍历所有的数据，这就会造成性能损失；")]),e._v(" "),_("p",[e._v("而且当新增或删除属性时需要使用Vue.set/delete这样特殊的api才能让数据具有响应性；而且对于ES6中新增的Map、Set这些数据结构也是不支持的")]),e._v(" "),_("h2",{attrs:{id:"vue3-中的响应式的新变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue3-中的响应式的新变化"}},[e._v("#")]),e._v(" vue3 中的响应式的新变化")]),e._v(" "),_("p",[e._v("为了解决Vue2中的一些问题，Vue3重新编写了数据响应式的实现：利用ES6的"),_("code",[e._v("Proxy")]),e._v("机制代理要响应化的数据。")]),e._v(" "),_("p",[_("code",[e._v("Proxy")]),e._v("有很多好处，首先再也不需要在动态新增和删除数据的时候使用Vue.set/delete这样的API了，让Vue的编程体验一致。")]),e._v(" "),_("p",[e._v("在初始化时对性能影响和内存消耗得到了大幅度改善，因为"),_("code",[e._v("Proxy")]),e._v("代理的是一整个对象而不需要在初始化时就递归遍历，只有等用到深层次的数据")]),e._v(" "),_("p",[e._v("时它才会去做对应的代理。而且Vue3将响应化的实现代码抽离成了一个独立的reactivity包，这使得开发者可以更灵活的使用它。并且它")]),e._v(" "),_("p",[e._v("能脱离Vue使用。")]),e._v(" "),_("h2",{attrs:{id:"源码学习简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#源码学习简介"}},[e._v("#")]),e._v(" 源码学习简介")]),e._v(" "),_("ol",[_("li",[e._v("首先关注源码中最重要的一个方式就是 "),_("code",[e._v("defineReactive")])])]),e._v(" "),_("p",[e._v("这个方法内部就是通过"),_("code",[e._v("Object.defineProperty()")]),e._v("来对数据进行数据拦截的，通过定义数据的"),_("code",[e._v("getter")]),e._v("对")]),e._v(" "),_("p",[e._v("使用(访问)该了数据的依赖进行收集，并且会对数据进行递归收集依赖。通过定义数据"),_("code",[e._v("setter")]),e._v("可以在数据被改变时")]),e._v(" "),_("p",[e._v("通知该数据的依赖从而更新视图。")]),e._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[e._v("就是要对 "),_("code",[e._v("Observer 类")]),e._v(" 和 "),_("code",[e._v("observe 方法")]),e._v(" 了解")])]),e._v(" "),_("p",[_("code",[e._v("Observer类")]),e._v("，它的作用就是通过"),_("code",[e._v("defineReactive()")]),e._v("给对象和数组属性的数据添加 getter 和 setter，用于依赖收集和派发更新")]),e._v(" "),_("p",[_("code",[e._v("observe 方法")]),e._v("的作用就是给非 VNode 的对象类型数据添加一个 Observer，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 Observer 对象实例。")]),e._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[_("p",[e._v("了解Vue如何改写的数组的7个方法，其实主要也是通过"),_("code",[e._v("Object.defineProperty()")]),e._v("来实现的。")])]),e._v(" "),_("li",[_("p",[e._v("再就是我们还需要对"),_("code",[e._v("Dep 类")]),e._v("进行了解和学习，这就是依赖类了，其中有如下几个属性和几个方法")])])]),e._v(" "),_("ul",[_("li",[e._v("target 这是类的静态属性，它就是被收集的目标。\n"),_("ul",[_("li",[e._v("这个属性的通过 单独的 "),_("code",[e._v("pushTarget")]),e._v(" 和 "),_("code",[e._v("popTarget")]),e._v(" 来进行更新")])])]),e._v(" "),_("li",[e._v("subs 存放依赖的数组")]),e._v(" "),_("li",[e._v("id 使用的是uid，用来作为依赖的唯一标识")]),e._v(" "),_("li",[e._v("addSub 添加依赖")]),e._v(" "),_("li",[e._v("removeSub 删除依赖")]),e._v(" "),_("li",[e._v("depend 这个我理解为就是收集依赖的方法，它内部也是调用的addSub，只是做了一些判断")]),e._v(" "),_("li",[e._v("notify 这个是通知依赖，然后调用依赖的更新方法。")])]),e._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[e._v("然后就Watcher了，这个就帮助依赖和数据建立关系的一个观察者类，用来为模板上使用的数据收集依赖或更新依赖")])]),e._v(" "),_("ul",[_("li",[_("p",[e._v("在自身实例化时往属性订阅器(dep)里面添加自己")])]),e._v(" "),_("li",[_("p",[e._v("自身必须有一个update()方法")])]),e._v(" "),_("li",[_("p",[e._v("待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调")])]),e._v(" "),_("li",[_("p",[e._v("使用了发布订阅模式")]),e._v(" "),_("ul",[_("li",[e._v("发布者（数据生产方）：发布者不直接通知订阅者，也无需关系谁是订阅者，只需要将数据更新这个事情告诉消息代理")]),e._v(" "),_("li",[e._v("消息代理 ：消息代理通知订阅者它订阅的数据更新了")]),e._v(" "),_("li",[e._v("订阅者 (模板上使用数据的地方) ：订阅者通过订阅消息代理中自己使用了的数据就可以在这些数据被更新时收到通知")])])]),e._v(" "),_("li",[_("p",[e._v("其实从数据的角度来看每一个watcher实例其实也是个订阅者，用来为模板上使用的数据收集依赖或更新依赖")])])]),e._v(" "),_("p",[_("img",{attrs:{src:"https://v2.cn.vuejs.org/images/data.png",alt:"doc-tu"}})]),e._v(" "),_("p",[_("a",{attrs:{href:"https://github.com/vuejs/vue/blob/main/src/core/observer/index.ts",target:"_blank",rel:"noopener noreferrer"}},[e._v("源码地址"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=r.exports}}]);