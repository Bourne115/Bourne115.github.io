(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{611:function(s,t,a){"use strict";a.r(t);var e=a(14),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"_1-为什么需要-hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么需要-hooks"}},[s._v("#")]),s._v(" 1. 为什么需要 Hooks")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("在组件之间复用状态逻辑很麻烦")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("现有方案是通过 render props 、高阶组件 HOC 、context （providers + consumers），很容易形成组件中的嵌套地狱")])]),s._v(" "),a("li",[a("p",[s._v("如果使用Hook从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。这使得在组件间或社区内共享Hook变得更便捷")])])])]),s._v(" "),a("li",[a("p",[s._v("复杂组件变得难以理解")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("组件变复杂时，会被各种状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。比如组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是同一个 componentDidMount中可能包含很多其他的逻辑，如设置事件监听，而之后需要在componentWillUnmount中清除。相互关联且需要按照修改的代码进行拆分，而完全不相关的代码却在同一个地方组合在一起。如此很容易产生BUG，并且导致逻辑不一致。")])]),s._v(" "),a("li",[a("p",[s._v("大部分情况下，不可能将组件拆分为更小的粒度，因为状态无处不在。这也是 Redux 和 Mobx 等状态管理库出现的原因之一但这又增加了很多抽象概念增加成本。")])]),s._v(" "),a("li",[a("p",[s._v("Hook将组件中相互管理的部分拆分成更小的函数，而非强制按照生命周期划分。")])])])]),s._v(" "),a("li",[a("p",[s._v("难以理解的class")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("需要理解 this 的工作方式 增加开发者的心智负担，虽然这是js的基本功。")])]),s._v(" "),a("li",[a("p",[s._v("class 不能很好的压缩，并且会使热重载出现不稳定的情况")])]),s._v(" "),a("li",[a("p",[s._v("Hook使开发者在非class的情况下可以使用更多的React特性。从概念上讲，React组件一直更像是函数。而 Hook 则拥抱了函数。")])]),s._v(" "),a("li",[a("p",[s._v("要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题")])])])])]),s._v(" "),a("h2",{attrs:{id:"_2-hook是啥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-hook是啥"}},[s._v("#")]),s._v(" 2.Hook是啥？")]),s._v(" "),a("blockquote",[a("p",[s._v("专业解读: 系统运行到某一时期时，会调用被注册到该时机的回调函数。")])]),s._v(" "),a("h3",{attrs:{id:"几个概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#几个概念"}},[s._v("#")]),s._v(" 几个概念")]),s._v(" "),a("ul",[a("li",[s._v("关注点分离")])]),s._v(" "),a("blockquote",[a("p",[s._v("把做什么和怎么做分离")])]),s._v(" "),a("ul",[a("li",[s._v("副作用")])]),s._v(" "),a("blockquote",[a("p",[s._v("副作用是函数式编程中的概念，其中函数式编程是一种编程范式，和 OOP 面向对象编程一样。")])]),s._v(" "),a("ul",[a("li",[s._v("类组件是数据和逻辑的封装")])]),s._v(" "),a("blockquote",[a("p",[s._v("也就是说，组件的状态和操作方法是封装在一起。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面")])]),s._v(" "),a("ul",[a("li",[s._v("函数组件一般来说，只应该做一件事，就是返回一个值。")])]),s._v(" "),a("blockquote",[a("p",[s._v("如果你多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据这种理念，React的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他功能。")])]),s._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("React Hook 就是一个特殊的函数，可以让你 钩入  React的特性。")]),s._v(" "),a("p",[s._v("一句话，钩子就是 React 函数组件的副作用解决方案，用来为函数组件引入副作用。函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副作用）都必须通过钩子引入。")]),s._v(" "),a("h2",{attrs:{id:"_3-对hook的正确认知"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-对hook的正确认知"}},[s._v("#")]),s._v(" 3.对Hook的正确认知")]),s._v(" "),a("p",[s._v("先理解一个初中的数学知识，自变量和因变量，")]),s._v(" "),a("p",[s._v("eg： 2x + 1 = y , 其中x的变化会导致y的变化，因此 x 是自变量， y  是因变量。")]),s._v(" "),a("p",[s._v("在react中常见的7个 hooks ，除了 useRef 之外可以通过自变量和因变量进行归类")]),s._v(" "),a("ul",[a("li",[s._v("自变量")])]),s._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/** 保存状态，让函数组件可以使用state */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/** useState 的替代方案,其实就是用 Redux 的方式合并管理state */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useReducer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/** 保存上下文  */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useContext")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("ul",[a("li",[s._v("因变量")])]),s._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**用于缓存一个因变量。需要显示的指定该因变量依赖的自变量。 */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useMemo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useMemo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**第一个参数是接收一个包含命令式，且可能有副作用代码的函数。 */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useEffect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**用于缓存一个函数类型的因变量，也需要显示的指定该因变量依赖的自变量。 */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useCallback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("ul",[a("li",[s._v("其它")])]),s._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/** 保存引用  */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useRef")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"usestate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[s._v("#")]),s._v(" useState：")]),s._v(" "),a("hr"),s._v(" "),a("p",[a("img",{attrs:{src:"https://www.rishiqing.com/task/v1/folder/file/url?signature=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0eXBlIjoidmlldyIsImlhdCI6MTY1OTk1MDU4NiwiZmlsZUlkIjo2OTA0ODg2LCJ0aW1lc3RhbXAiOjE2NTk5NTA1ODYzMTF9.92hgFRjke-2GF9-38GDnTTV6TLBcLbDYUKfKnOr1kCg",alt:"tu"}})]),s._v(" "),a("hr"),s._v(" "),a("p",[a("img",{attrs:{src:"https://www.rishiqing.com/task/v1/folder/file/url?signature=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0eXBlIjoidmlldyIsImlhdCI6MTY1OTk1MDc1MCwiZmlsZUlkIjo2OTA0OTIyLCJ0aW1lc3RhbXAiOjE2NTk5NTA3NTAyNTh9.4Pxqw7r-8kXpgOsHR1zsbNKI_OGpX0bv8qYQ2b6D5oY",alt:"tu"}})]),s._v(" "),a("hr"),s._v(" "),a("p",[a("img",{attrs:{src:"https://www.rishiqing.com/task/v1/folder/file/url?signature=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0eXBlIjoidmlldyIsImlhdCI6MTY1OTk1MDc5OSwiZmlsZUlkIjo2OTA0OTI4LCJ0aW1lc3RhbXAiOjE2NTk5NTA3OTk3MzB9.oLvMUBHKzgyF76qXuq9asR7b4u5fPJO__5_CeuVS5Qc",alt:"tu"}})]),s._v(" "),a("hr"),s._v(" "),a("h3",{attrs:{id:"useeffect"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[s._v("#")]),s._v(" useEffect：")]),s._v(" "),a("ul",[a("li",[s._v("更新机制：默认情况下，useEffect它会在第一次渲染之后和每次更新之后都会执行。因此我们还需掌握如何控制它。")])]),s._v(" "),a("hr"),s._v(" "),a("ul",[a("li",[s._v("先了解一个什么是纯函数：\n对于一个函数，如果固定的输入一定会产生固定的输出")])]),s._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("calcNum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("number")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("通过对纯函数的简单了解，在来理解副作用就会好多了：\n列如下面的代码，我们引入了随机数 z 就会导致 输入的 X 是固定的，但输出是不固定的。这时 calcNum 这个函数是包含副作用的。")])]),s._v(" "),a("p",[s._v("在 hooks 中 可以使用 useEffect 来定义有副作用的因变量")]),s._v(" "),a("ul",[a("li",[s._v("列如在useEffect中 ，操作DOM  请求数据 这些有副作用的逻辑")])]),s._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("calcNum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v("  z "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" Math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("random")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" z\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useEffect")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("title "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" x\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[a("strong",[s._v("总结：")]),s._v(" hooks 中 useState定义自变量，useMemo、 useCallback 定义无副作用的因变量，useEffect定义的是有副作用的因变量。\nuseReducer可以看作是进阶版的useState，它使用 redux 的理念将多个 state 合并为一个，本质上也是因变量。")]),s._v(" "),a("h3",{attrs:{id:"usecontext"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[s._v("#")]),s._v(" useContext")]),s._v(" "),a("p",[s._v("如何跨组件层级来传递自变量，如果不想通过props来一级一级的传递。此时就需要使用 useContext  实现了。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://www.rishiqing.com/task/v1/folder/file/url?signature=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0eXBlIjoidmlldyIsImlhdCI6MTY1OTk1MjA0OSwiZmlsZUlkIjo2OTA1MTUyLCJ0aW1lc3RhbXAiOjE2NTk5NTIwNDkyNzh9.Nr44g2RSGgoBME86E1Gq8U1U4kqVKt6gsC9IYc55rg0",alt:"tu"}})]),s._v(" "),a("h3",{attrs:{id:"useref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[s._v("#")]),s._v(" useRef")]),s._v(" "),a("div",{staticClass:"language-jsx line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("useRef")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("initialValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("useRef 返回一个可变的ref对象，其 "),a("code",[s._v(".current")]),s._v("属性被初始化为传入的参数(initialValue)。返回的 ref 对象在组件的整个生命周期\n内保持不变。")]),s._v(" "),a("ul",[a("li",[s._v("解决引用问题---useRef 会在每次渲染时返回一个 ref 对象")]),s._v(" "),a("li",[s._v("解决一些 this 指向问题")]),s._v(" "),a("li",[s._v("对比 createRef --- 在初始化阶段两个是没有区别的，但是在更新阶段两者是有区别的。")]),s._v(" "),a("li",[s._v("我们知道,在一个局部函数中，函数每一次 update，都会在把函数的变量重新生成一次。\n所以我们每更新一次组件, 就重新创建一次 ref， 这个时候继续使用 createRef 显然不合适，所以官方推出 useRef。useRef 创建的 ref 仿佛就像在函数外部定义的一个全局变量，不会随着组件的更新而重新创建。但组件销毁，它也会消失，不用手动进行销毁")])]),s._v(" "),a("p",[a("strong",[s._v("总结")])]),s._v(" "),a("p",[s._v("createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://www.rishiqing.com/task/v1/folder/file/url?signature=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0eXBlIjoidmlldyIsImlhdCI6MTY1OTk1MjE3OCwiZmlsZUlkIjo2OTA1MTYxLCJ0aW1lc3RhbXAiOjE2NTk5NTIxNzg0ODR9.Z47BxSddaYk4f8NdNZSHNuEewOANLHjzncMaX2vjuP4",alt:"tu"}})]),s._v(" "),a("h2",{attrs:{id:"_4-hook使用规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-hook使用规则"}},[s._v("#")]),s._v(" 4.Hook使用规则")]),s._v(" "),a("ul",[a("li",[s._v("只在最顶层使用 Hook ，不要在循环，条件或嵌套函数中调用 Hook，确保总是在你的React函数的最顶层以及任何 return 之前调用他们。")]),s._v(" "),a("li",[s._v("只在 React 函数中调用 Hook")]),s._v(" "),a("li",[s._v("在 React 的函数组件中调用 Hook")]),s._v(" "),a("li",[s._v("在自定义 Hook 中调用其他 Hook")]),s._v(" "),a("li",[s._v("用 useXxxx 小驼峰命名自定义 Hook")]),s._v(" "),a("li",[s._v("自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，它就像一个正常的函数。但是它的名字应该始终以 use 开头")])]),s._v(" "),a("h2",{attrs:{id:"_5-代数效应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-代数效应"}},[s._v("#")]),s._v(" 5.代数效应")]),s._v(" "),a("ul",[a("li",[s._v("react的hooks是对代数效应的践行")]),s._v(" "),a("li",[s._v("代数效应是函数式编程的一个概念")])]),s._v(" "),a("p",[a("strong",[s._v("一句总结，就是将副作用当参数一样传递")])]),s._v(" "),a("p",[s._v("其实我对这个代数效应还是云里雾里的，直到看了 蛋总的这篇 通俗易懂的 代数效应，才慢慢有点思路")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/",target:"_blank",rel:"noopener noreferrer"}},[s._v("蛋总的文章写的真棒👍🏻"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);